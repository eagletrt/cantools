import re
import time
from typing import List
from decimal import Decimal

from ...version import __version__

type_to_specifier = {"uint8_t": '%" PRIu8  "',
                    "uint16_t": '%" PRIu16 "',
                    "uint32_t": '%" PRIu32 "',
                    "uint64_t": '%" PRIu64 "',
                    "int8_t":   '%" PRIi8  "',
                    "int16_t":  '%" PRIi16 "',
                    "int32_t":  '%" PRIi32 "',
                    "int64_t":  '%" PRIi64 "',
                    "float": "%f",
                    "double": "%f"}

HEADER_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version {version} {date}.
 */

#ifndef {include_guard}
#define {include_guard}

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {{
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "../canlib_device.h"

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME {timestamp}
#endif // CANLIB_BUILD

#define canlib_min(a,b) (((a) < (b)) ? (a) : (b))
#define canlib_max(a,b) (((a) > (b)) ? (a) : (b))

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                         \
  __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* General defines */
{general_defines}

/* Frame ids. */
{frame_id_defines}

/* Frame lengths in bytes. */
{frame_length_defines}

/* Extended or standard frame types. */
{is_extended_frame_defines}

/* Frame cycle times in milliseconds. */
{frame_cycle_time_defines}

/* Topics masks */
{masks_define}

/* Signal choices. */
{choices_defines}

/* Indexes */
{message_indexes}

#define {database_name}_MESSAGE_COUNT {msg_count}

void {database_name}_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int {database_name}_serialize_from_id(
    void* converted_struct_pointer,
    uint16_t message_id,
    uint8_t* data
);

int {database_name}_message_name_from_id(uint16_t id, char* buffer);
int {database_name}_index_from_id(uint16_t id);
int {database_name}_id_from_index(int index);

{structs}
{declarations}


{unions}


#define {database_name}_MAX_STRUCT_SIZE_RAW sizeof(_{database_name}_all_struct_raw)
#define {database_name}_MAX_STRUCT_SIZE_CONVERSION sizeof(_{database_name}_all_struct_converted)

#ifdef __cplusplus
}}
#endif

#endif
'''

SOURCE_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version {version} {date}.
 */

#include <string.h>

#include "{header}"

{helpers}\
{definitions}\
'''

DEVICES_HEADER='''#ifndef CANLIB_DEVICE_H
#define CANLIB_DEVICE_H

#include <stddef.h>
#include <stdlib.h>

typedef struct {
    void* message;
    void* _converted;
    void* _raw;
    int _size_raw;
    int _size_converted;
} device_t;
void device_init(device_t *device);
void device_preallocate(device_t *device, int bytes);
void device_free(device_t *device);
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size);

#endif // CANLIB_DEVICE_H
'''

DEVICES_SOURCE='''#include "canlib_device.h"

void device_init(device_t *device) {
    device->message = NULL;
    device->_converted = NULL;
    device->_raw = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_preallocate(device_t *device, int bytes){
    if(device->_size_raw > 0)
        free(device->_raw);
    if(device->_size_converted > 0)
        free(device->_converted);
    device->_raw = malloc(bytes);
    device->_converted = malloc(bytes);
    device->_size_converted = device->_size_raw = bytes;
}
void device_free(device_t *device) {
    free(device->_raw);
    free(device->_converted);
    device->message = NULL;
    device->_raw = NULL;
    device->_converted = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size) {
    device->_raw = raw;
    device->_converted = converted;
    device->_size_raw = raw_size;
    device->_size_converted = converted_size;
}
'''

FUZZER_SOURCE_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version {version} {date}.
 */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "{header}"

static void assert_first_pack(int res)
{{
    if (res < 0) {{
        printf("First pack failed with %ld.\\n", res);
        __builtin_trap();
    }}
}}

static void assert_second_unpack(int res)
{{
    if (res < 0) {{
        printf("Second unpack failed with %ld.\\n", res);
        __builtin_trap();
    }}
}}

static void assert_second_unpack_data(const void *unpacked_p,
                                      const void *unpacked2_p,
                                      size_t size)
{{
    if (memcmp(unpacked_p, unpacked2_p, size) != 0) {{
        printf("Second unpacked data does not match first unpacked data.\\n");
        __builtin_trap();
    }}
}}

static void assert_second_pack(int res, int res2)
{{
    if (res != res2) {{
        printf("Second pack result %ld does not match first pack "
               "result %ld.\\n",
               res,
               res2);
        __builtin_trap();
    }}
}}

static void assert_second_pack_data(const uint8_t *packed_p,
                                    const uint8_t *packed2_p,
                                    int size)
{{
    int i;

    if (memcmp(packed_p, packed2_p, size) != 0) {{
        for (i = 0; i < size; i++) {{
            printf("[%04ld]: 0x%02x 0x%02x\\n", i, packed_p[i], packed2_p[i]);
        }}

        __builtin_trap();
    }}
}}

{tests}

int LLVMFuzzerTestOneInput(const uint8_t *data_p, size_t size)
{{
{llvm_body}

    return (0);
}}
'''

FUZZER_MAKEFILE_FMT = '''\
#
# The MIT License (MIT)
#
# Copyright (c) 2018-2019 Erik Moqvist
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

#
# This file was generated by cantools version {version} {date}.
#

CC = clang
EXE = fuzzer
C_SOURCES = \\
\t{source} \\
\t{fuzzer_source}
CFLAGS = \\
\t-fprofile-instr-generate \\
\t-fcoverage-mapping \\
\t-I. \\
\t-g -fsanitize=address,fuzzer \\
\t-fsanitize=signed-integer-overflow \\
\t-fno-sanitize-recover=all
EXECUTION_TIME ?= 5

all:
\t$(CC) $(CFLAGS) $(C_SOURCES) -o $(EXE)
\trm -f $(EXE).profraw
\tLLVM_PROFILE_FILE="$(EXE).profraw" \\
\t    ./$(EXE) \\
\t    -max_total_time=$(EXECUTION_TIME)
\tllvm-profdata merge -sparse $(EXE).profraw -o $(EXE).profdata
\tllvm-cov show ./$(EXE) -instr-profile=$(EXE).profdata
\tllvm-cov report ./$(EXE) -instr-profile=$(EXE).profdata

'''

TEST_FMT = '''
static void test_{name}(
    const uint8_t *packed_p,
    size_t size)
{{
    int res;
    int res2;
    uint8_t packed[size];
    uint8_t packed2[size];
    {name}_t unpacked;
    {name}_t unpacked2;

    memset(&unpacked, 0, sizeof(unpacked));

    res = {name}_unpack(
        &unpacked,
        packed_p,
        size);

    if (res >= 0) {{
        res = {name}_pack(
            &packed[0],
            &unpacked,
            sizeof(packed));

        assert_first_pack(res);

        memset(&unpacked2, 0, sizeof(unpacked2));

        res2 = {name}_unpack(
            &unpacked2,
            &packed[0],
            res);

        assert_second_unpack(res2);
        assert_second_unpack_data(&unpacked,
                                  &unpacked2,
                                  sizeof(unpacked));

        res2 = {name}_pack(
            &packed2[0],
            &unpacked,
            sizeof(packed2));

        assert_second_pack(res, res2);
        assert_second_pack_data(&packed[0], &packed2[0], res);
    }}
}}\
'''

STRUCT_FMT = '''\
/**
 * Signals in message {database_message_name}.
 *
{comment}\
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {{
{members}

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
}} {database_name}_{message_name}_t;
'''

MESSAGE_INDEX = '''#define {database_name}_{message_name}_INDEX {index}
'''

DEVICES_DEFINITIONS = '''
void {database_name}_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
    #ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
    #endif // CANLIB_TIMESTAMP
)
{{
    switch(message_id){{
{devices_deserialize_body}
    }}
}}
int {database_name}_serialize_from_id(
    void* converted_struct_pointer,
    uint16_t message_id,
    uint8_t* data
)
{{
    switch(message_id){{
{devices_serialize_body}
    }}
    return -1;
}}
'''

DEVICE_MESSAGE_DESERIALIZE = '''\
        case {id}: {{
            if(sizeof({database_name}_{message_name}_t) > device->_size_raw) {{
                free(device->_raw);
                device->_raw = malloc(sizeof({database_name}_{message_name}_t));
                device->_size_raw = sizeof({database_name}_{message_name}_t);
            }}
            {database_name}_{message_name}_unpack(
                ({database_name}_{message_name}_t*) device->_raw,
                data,
                {message_length}
                #ifdef CANLIB_TIMESTAMP
                , timestamp
                #endif
            );
            device->message = device->_raw;
            {conversion_component}
            return;
        }}
'''
DEVICE_MESSAGE_DESERIALIZE_CONVERSION_COMPONENT = '''
            if(sizeof({database_name}_{message_name}_converted_t) > device->_size_converted) {{
                free(device->_converted);
                device->_converted = malloc(sizeof({database_name}_{message_name}_converted_t));
                device->_size_converted = sizeof({database_name}_{message_name}_converted_t);
            }}
            {database_name}_{message_name}_raw_to_conversion_struct(
                ({database_name}_{message_name}_converted_t*) device->_converted,
                ({database_name}_{message_name}_t*) device->_raw
            );
            device->message = device->_converted;
'''
DEVICE_MESSAGE_SERIALIZE_CONVERSION = '''
        case {id}: {{
            {database_name}_{message_name}_t raw;
            {database_name}_{message_name}_conversion_to_raw_struct(
                        ({database_name}_{message_name}_t*) &raw,
                        ({database_name}_{message_name}_converted_t*) converted_struct_pointer
            );
            return {database_name}_{message_name}_pack(data, &raw, {message_length});
        }}'''
DEVICE_MESSAGE_SERIALIZE_RAW = '''
        case {id}: {{
            return {database_name}_{message_name}_pack(data, ({database_name}_{message_name}_t*) converted_struct_pointer, {message_length});
        }}'''

NET_ID_IS_MESSAGE_DECLARATION = '''\
bool {database_name}_id_is_message(uint16_t id);
'''
NET_ID_IS_MESSAGE_DEFINITION = '''\
bool {database_name}_id_is_message(uint16_t id){{
    switch(id){{
{net_id_is_message_body}        return true;
        break;
    default:
        return false;
    }}
}}
'''
NET_ID_IS_MESSAGE_BODY = '''\
        case {db_name}_{msg_name}_FRAME_ID:
'''

DECLARATION_PACK_FMT = '''\
/**
 * Pack message {database_message_name}.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int {database_name}_{message_name}_pack(
    uint8_t *dst_p,
    const {database_name}_{message_name}_t *src_p,
    size_t byte_size);

'''

DECLARATION_UNPACK_FMT = '''\
/**
 * Unpack message {database_message_name}.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int {database_name}_{message_name}_unpack(
    {database_name}_{message_name}_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );
'''

SIGNAL_DECLARATION_ENCODE_FMT = '''\
/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
{type_name} {database_name}_{message_name}_{signal_name}_encode({conversion_type} value);

'''

MESSAGE_DECLARATION_RAW_TO_CONVERSION_STRUCT = '''
void {database_name}_{message_name}_raw_to_conversion_struct(
    {struct_type_out} *conversion, 
    {struct_type_in} *raw);
'''

MESSAGE_DECLARATION_CONVERSION_TO_RAW_STRUCT = '''
void {database_name}_{message_name}_conversion_to_raw_struct(
    {struct_type_in} *raw,
    {struct_type_out} *conversion);
'''

SIGNAL_ENUM_START_DECLARATION = '''typedef enum {
'''
SIGNAL_ENUM_END_DECLARATION = '''}} {type_name};
'''

SIGNAL_DECLARATION_DECODE_FMT = '''\
/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
{conversion_type} {database_name}_{message_name}_{signal_name}_decode({type_name} value);

'''

SIGNAL_DECLARATION_IS_IN_RANGE_FMT = '''\
/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool {database_name}_{message_name}_{signal_name}_is_in_range({type_name} value);
'''

PACK_HELPER_LEFT_SHIFT_FMT = '''\
static uint8_t pack_left_shift_u{length}(
    {var_type} value,
    uint8_t shift,
    uint8_t mask)
{{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}}
'''

PACK_HELPER_RIGHT_SHIFT_FMT = '''\
static uint8_t pack_right_shift_u{length}(
    {var_type} value,
    uint8_t shift,
    uint8_t mask)
{{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}}
'''

UNPACK_HELPER_LEFT_SHIFT_FMT = '''\
static {var_type} unpack_left_shift_u{length}(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{{
    return ({var_type})(({var_type})(value & mask) << shift);
}}
'''

UNPACK_HELPER_RIGHT_SHIFT_FMT = '''\
static {var_type} unpack_right_shift_u{length}(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{{
    return ({var_type})(({var_type})(value & mask) >> shift);
}}
'''

DEFINITION_PACK_FMT = '''\
int {database_name}_{message_name}_pack(
    uint8_t *dst_p,
    const {database_name}_{message_name}_t *src_p,
    size_t byte_size)
{{
{pack_unused}\
{pack_variables}\
    if (byte_size < {message_length}u) {{
        return (-EINVAL);
    }}

    memset(dst_p, 0, {message_length});
{pack_body}
    return ({message_length});
}}

'''

DEFINITION_UNPACK_FMT = '''\
int {database_name}_{message_name}_unpack(
    {database_name}_{message_name}_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    )
{{
{unpack_unused}\
{unpack_variables}\
    if (byte_size < {message_length}u) {{
        return (-EINVAL);
    }}
#ifdef CANLIB_TIMESTAMP
    dst_p->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
{unpack_body}
    return (0);
}}
'''

MESSAGE_DEFINITION_RAW_TO_CONVERSION_STRUCT = '''
void {database_name}_{message_name}_raw_to_conversion_struct(
    {struct_type_out} *conversion, 
    {struct_type_in} *raw)
{{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = raw->_timestamp;
#endif // CANLIB_TIMESTAMP
'''

MESSAGE_DEFINITION_CONVERSION_TO_RAW= '''
void {database_name}_{message_name}_conversion_to_raw(
    {struct_type} *raw,
{signals}
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
'''

MESSAGE_DEFINITION_RAW_TO_CONVERSION= '''
void {database_name}_{message_name}_raw_to_conversion(
    {struct_type} *conversion,
{signals}
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
'''

MESSAGE_DEFINITION_CONVERSION_TO_RAW_STRUCT = '''
void {database_name}_{message_name}_conversion_to_raw_struct(
    {struct_type_in} *raw,
    {struct_type_out} *conversion)
{{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = conversion->_timestamp;
#endif // CANLIB_TIMESTAMP
'''

SIGNAL_DECLARATION_TO_ = '''    {signal_type} {signal_name},
'''

SIGNAL_DEFINITION_RAW_TO_CONVERT_STRUCT_DECODE = '''    conversion->{signal_name} = {database_name}_{message_name}_{signal_name}_decode(raw->{signal_name});
'''
SIGNAL_DEFINITION_CONVERT_TO_RAW_STRUCT_ENCODE = '''    raw->{signal_name} = {database_name}_{message_name}_{signal_name}_encode(conversion->{signal_name});
'''
SIGNAL_DEFINITION_RAW_TO_CONVERT_DECODE = '''    conversion->{signal_name} = {database_name}_{message_name}_{signal_name}_decode({signal_name});
'''
SIGNAL_DEFINITION_CONVERT_TO_RAW_ENCODE = '''    raw->{signal_name} = {database_name}_{message_name}_{signal_name}_encode({signal_name});
'''

SIGNAL_DEFINITION_RAW_TO_CONVERT_STRUCT = '''    conversion->{signal_name} = raw->{signal_name};
'''
SIGNAL_DEFINITION_CONVERT_TO_RAW_STRUCT = '''    raw->{signal_name} = conversion->{signal_name};
'''
SIGNAL_DEFINITION_RAW_TO_CONVERT = '''    conversion->{signal_name} = {signal_name};
'''
SIGNAL_DEFINITION_CONVERT_TO_RAW = '''    raw->{signal_name} = {signal_name};
'''

SIGNAL_DEFINITION_ENCODE_FMT = '''\
{type_name} {database_name}_{message_name}_{signal_name}_encode({conversion_type} value)
{{
    return ({type_name})({encode});
}}

'''

SIGNAL_DEFINITION_DECODE_FMT = '''\
{conversion_type} {database_name}_{message_name}_{signal_name}_decode({type_name} value)
{{
    return ({decode});
}}

'''

SIGNAL_DEFINITION_IS_IN_RANGE_FMT = '''\
bool {database_name}_{message_name}_{signal_name}_is_in_range({type_name} value)
{{
{unused}\
    return ({check});
}}
'''

EMPTY_DEFINITION_FMT = '''\
int {database_name}_{message_name}_pack(
    uint8_t *dst_p,
    const {database_name}_{message_name}_t *src_p,
    size_t size)
{{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}}

int {database_name}_{message_name}_unpack(
    {database_name}_{message_name}_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
)
{{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}}
'''

SIGN_EXTENSION_FMT = '''
    if (({name} & (1{suffix} << {shift})) != 0{suffix}) {{
        {name} |= 0x{mask:x}{suffix};
    }}

'''

SIGNAL_MEMBER_FMT = '''\
    /**
{comment}\
     * Range: {range}
     * Scale: {scale}
     * Offset: {offset}
     */
    {type_name} {name}{length};\
'''
SIGNAL_MEMBER_FMT_BOOL = '''\
    /**
{comment}\
     * Range: {range}
     * Scale: {scale}
     * Offset: {offset}
     */
    unsigned int {name}{length} : 1;\
'''

MESSAGE_DECLARATION_TO_STRING = '''int {database_name}_{message_name}_to_string({database_name}_{message_name}_t *message, char *buffer);
'''

MESSAGE_DEFINITION_TO_STRING = '''int {database_name}_{message_name}_to_string({database_name}_{message_name}_t *message, char *buffer){{
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
'''

DEFINITION_TO_STRING_FILE_NO_SIGNALS = '''int {database_name}_{message_name}_to_string({database_name}_{message_name}_t *message, char *buffer){{return 0;}}
int {database_name}_{message_name}_fields(char *buffer) {{return 0;}}
int {database_name}_{message_name}_to_string_file({database_name}_{message_name}_t *message, FILE *buffer){{return 0;}}
int {database_name}_{message_name}_fields_file(FILE *buffer){{return 0;}}
'''

SIGNAL_DEFINITION_SPECIFIER = '''    "{specifier}"","
'''
SIGNAL_DEFINITION_TO_STRING = '''    message->{signal_name},
'''

ENUM_TO_STRING = '''int {database_name}_{message_name}_{signal_name}_enum_to_string({database_name}_{message_name}_{signal_name} value, char *buffer){{
    switch(value)
    {{
{body}
    }}
    sprintf(buffer, "CANLIB_UNKNOWN");
    return -1;
}}'''
ENUM_TO_STRING_DECLARATION = '''int {database_name}_{message_name}_{signal_name}_enum_to_string({database_name}_{message_name}_{signal_name} value, char *buffer);\n'''

BITSET_BIT_OP_DECLARATION = '''
void {database_name}_{message_name}_{signal_name}_set_bit({database_name}_{message_name}_{signal_name}_t *bitset, uint8_t bit, uint8_t value);
uint8_t {database_name}_{message_name}_{signal_name}_get_bit(const {database_name}_{message_name}_{signal_name}_t *bitset, uint8_t bit);
{enum_type} {database_name}_{message_name}_{signal_name}_to_uint(const {database_name}_{message_name}_{signal_name}_t *bitset);
'''
BITSET_BIT_SET_DEFINITION = '''
void {database_name}_{message_name}_{signal_name}_set_bit({database_name}_{message_name}_{signal_name}_t *bitset, uint8_t bit, uint8_t value)
{{
    // cast a c bitset to uint8
    {enum_type} *bitset_uint8 = ({enum_type} *)bitset;
    if (bit > sizeof({enum_type}))
        return;
    
    if (value == 0)
        *bitset_uint8 &= ~(1 << bit);
    else
        *bitset_uint8 |= (1 << bit);
}}
'''

CHOICE_TO_STRING = '''\t\tcase {case}: return sprintf(buffer, "{choice}");\n'''

MESSAGE_DECLARATION_FIELDS = '''int {database_name}_{message_name}_fields(char *buffer);
'''

MESSAGE_DEFINITION_FIELDS = '''int {database_name}_{message_name}_fields(char *buffer){{
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
'''

SIGNAL_DEFINITION_FIELDS = '''    "{signal_name}"","
'''

#FILE

MESSAGE_DECLARATION_TO_STRING_FILE = '''int {database_name}_{message_name}_to_string_file({database_name}_{message_name}_t *message, FILE *buffer);
'''

MESSAGE_DEFINITION_TO_STRING_FILE = '''int {database_name}_{message_name}_to_string_file({database_name}_{message_name}_t *message, FILE *buffer){{
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
'''

MESSAGE_DECLARATION_FIELDS_FILE = '''int {database_name}_{message_name}_fields_file(FILE *buffer);
'''

MESSAGE_DEFINITION_FIELDS_FILE = '''int {database_name}_{message_name}_fields_file(FILE *buffer){{
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
'''

MESSAGE_STRING_FROM_ID = '''    case {id}:
            return {database_name}_{message_name}_to_string(({database_name}_{message_name}_t*) message,
                                                buffer);
    '''
MESSAGE_FIELD_FROM_ID = '''    case {id}:
            return {database_name}_{message_name}_fields(buffer);
    '''

MESSAGE_FILE_FROM_ID = '''    case {id}:
            return {database_name}_{message_name}_to_string_file(({database_name}_{message_name}_t*) message, buffer);
    '''
MESSAGE_FIELD_FILE_FROM_ID = '''    case {id}:
            return {database_name}_{message_name}_fields_file(buffer);
    '''

MSG_NAME_FROM_ID = '''int {database_name}_message_name_from_id(uint16_t id, char* buffer) {{
    switch (id) {{
{body}\
    }}
    return 0;
}}
'''
ID_FROM_INDEX = '''int {database_name}_id_from_index(int index){{
    switch (index) {{
{body}\
    }}
    return -1;
}}
'''
INDEX_FROM_ID = '''int {database_name}_index_from_id(uint16_t id) {{
    switch (id) {{
{body}\
    }}
    return -1;
}}
'''
MSG_NAME_FROM_ID_CONTENT = '''\t\tcase {}: return sprintf(buffer, "%s", "{}");\n'''

UNION = '''typedef union CANLIB_PARKING {{
{messages}
}} {name};
'''
MESSAGE_UNION = '''    {type_name} _{name};
'''

class Signal:

    def __init__(self, signal, message_name, database_name):
        self.database_name = database_name
        self.message_name = message_name
        self._signal = signal
        self.snake_name = camel_to_snake_case(self.name)

    def __getattr__(self, name):
        return getattr(self._signal, name)

    @property
    def unit(self):
        return _get(self._signal.unit, '-')
    
    @property
    def is_enum(self):
        return self._signal.choices != None

    @property
    def type_length(self):
        if self.length <= 8:
            return 8
        elif self.length <= 16:
            return 16
        elif self.length <= 32:
            return 32
        else:
            return 64

    @property
    def type_name(self):
        if self.is_float:
            if self.length == 32:
                type_name = 'float'
            else:
                type_name = 'double'
        else:
            type_name = f'int{self.type_length}_t'

            if not self.is_signed:
                type_name = 'u' + type_name

        return type_name

    @property
    def enum_name(self):
        return f'{self.database_name}_{self.message_name}_{self.snake_name}'

    @property
    def type_suffix(self):
        try:
            return {
                'uint8_t': 'u',
                'uint16_t': 'u',
                'uint32_t': 'u',
                'int64_t': 'll',
                'uint64_t': 'ull',
                'float': 'f'
            }[self.type_name]
        except KeyError:
            return ''

    @property
    def conversion_type_suffix(self):
        try:
            return {
                8: 'u',
                16: 'u',
                32: 'u',
                64: 'ull'
            }[self.type_length]
        except KeyError:
            return ''

    @property
    def unique_choices(self):
        """Make duplicated choice names unique by first appending its value
        and then underscores until unique.

        """

        items = {
            value: camel_to_snake_case(str(name)).upper()
            for value, name in self.choices.items()
        }
        names = list(items.values())
        duplicated_names = [
            name
            for name in set(names)
            if names.count(name) > 1
        ]
        unique_choices = {
            value: name
            for value, name in items.items()
            if names.count(name) == 1
        }

        for value, name in items.items():
            if name in duplicated_names:
                name += _canonical(f'_{value}')

                while name in unique_choices.values():
                    name += '_'

                unique_choices[value] = name

        return unique_choices

    @property
    def is_float_conversion(self):
        return self.is_float or _get(self.scale, '1') != 1 or _get(self.offset, '0') % 1 != 0 or self.minimum_value % 1 != 0 or self.maximum_value % 1 != 0
    @property
    def is_integer_conversion(self):
        return (not self.is_float_conversion) and _get(self.offset, '0') != 0

    @property
    def minimum_type_value(self):
        if self.type_name == 'int8_t':
            return -128
        elif self.type_name == 'int16_t':
            return -32768
        elif self.type_name == 'int32_t':
            return -2147483648
        elif self.type_name == 'int64_t':
            return -9223372036854775808
        elif self.type_name[0] == 'u':
            return 0
        else:
            return None

    @property
    def maximum_type_value(self):
        if self.type_name == 'int8_t':
            return 127
        elif self.type_name == 'int16_t':
            return 32767
        elif self.type_name == 'int32_t':
            return 2147483647
        elif self.type_name == 'int64_t':
            return 9223372036854775807
        elif self.type_name == 'uint8_t':
            return 255
        elif self.type_name == 'uint16_t':
            return 65535
        elif self.type_name == 'uint32_t':
            return 4294967295
        elif self.type_name == 'uint64_t':
            return 18446744073709551615
        else:
            return None

    @property
    def minimum_value(self):
        if self.is_float:
            return None
        elif self.is_signed:
            return -(2 ** (self.length - 1))
        else:
            return 0

    @property
    def maximum_value(self):
        if self.is_float:
            return None
        elif self.is_signed:
            return ((2 ** (self.length - 1)) - 1)
        else:
            return ((2 ** self.length) - 1)

    def segments(self, invert_shift):
        index, pos = divmod(self.start, 8)
        left = self.length

        while left > 0:
            if self.byte_order == 'big_endian':
                if left >= (pos + 1):
                    length = (pos + 1)
                    pos = 7
                    shift = -(left - length)
                    mask = ((1 << length) - 1)
                else:
                    length = left
                    shift = (pos - length + 1)
                    mask = ((1 << length) - 1)
                    mask <<= (pos - length + 1)
            else:
                shift = (left - self.length) + pos

                if left >= (8 - pos):
                    length = (8 - pos)
                    mask = ((1 << length) - 1)
                    mask <<= pos
                    pos = 0
                else:
                    length = left
                    mask = ((1 << length) - 1)
                    mask <<= pos

            if invert_shift:
                if shift < 0:
                    shift = -shift
                    shift_direction = 'left'
                else:
                    shift_direction = 'right'
            else:
                if shift < 0:
                    shift = -shift
                    shift_direction = 'right'
                else:
                    shift_direction = 'left'

            yield index, shift, shift_direction, mask

            left -= length
            index += 1


class Message:

    def __init__(self, message, database_name):
        self._message = message
        self.topic_name = message.topic_name    #json
        self.topic_id = message.topic_id        #json
        self.snake_name = camel_to_snake_case(self.name)
        self.database_name = database_name
        self.signals = [Signal(signal, self.snake_name, database_name)for signal in message.signals]
        self.has_conversions = False
        for sig in self.signals:
            if sig.is_float_conversion or sig.is_integer_conversion:
                self.has_conversions = True
                break
    
    @property
    def struct_name_converted(self):
        return f"{self.database_name}_{self.snake_name}_converted_t"
    @property
    def struct_name_raw(self):
        return f"{self.database_name}_{self.snake_name}_t"


    def __getattr__(self, name):
        return getattr(self._message, name)

    def get_signal_by_name(self, name):
        for signal in self.signals:
            if signal.name == name:
                return signal


def _canonical(value):
    """Replace anything but 'a-z', 'A-Z' and '0-9' with '_'.

    """

    return re.sub(r'[^a-zA-Z0-9]', '_', value)


def camel_to_snake_case(value):
    return value.lower()
    value = re.sub(r'(.)([A-Z][a-z]+)', r'\1_\2', value)
    value = re.sub(r'(_+)', '_', value)
    value = re.sub(r'([a-z0-9])([A-Z])', r'\1_\2', value).lower()
    value = _canonical(value)

    return value


def _strip_blank_lines(lines):
    try:
        while lines[0] == '':
            lines = lines[1:]

        while lines[-1] == '':
            lines = lines[:-1]
    except IndexError:
        pass

    return lines


def _get(value, default):
    if value is None:
        value = default

    return value


def _format_comment(comment):
    if comment:
        return '\n'.join([
            '     * ' + line.rstrip()
            for line in comment.splitlines()
        ]) + '\n     *\n'
    else:
        return ''


def _format_decimal(value, is_float=False, use_float=False):
    f_append = 'f' if use_float else ''
    if int(value) == value:
        value = int(value)

        if is_float:
            return f'{value}.0{f_append}'
        else:
            return str(value)
    else:
        return f'{value}{f_append}'


def _format_range(signal):
    minimum = signal.decimal.minimum
    maximum = signal.decimal.maximum
    scale = signal.decimal.scale
    offset = signal.decimal.offset

    if minimum is not None and maximum is not None:
        return '{}..{} ({}..{} {})'.format(
            _format_decimal((minimum - offset) / scale),
            _format_decimal((maximum - offset) / scale),
            minimum,
            maximum,
            signal.unit)
    elif minimum is not None:
        return '{}.. ({}.. {})'.format(
            _format_decimal((minimum - offset) / scale),
            minimum,
            signal.unit)
    elif maximum is not None:
        return '..{} (..{} {})'.format(
            _format_decimal((maximum - offset) / scale),
            maximum,
            signal.unit)
    else:
        return '-'

def _generate_signal_converted(signal, bit_fields, database_name, message):
    comment = _format_comment(signal.comment)
    range_ = _format_range(signal)
    scale = _get(signal.scale, '-')
    offset = _get(signal.offset, '-')

    if signal.is_float or not bit_fields:
        length = ''
    else:
        length = ' : {}'.format(signal.length)

    if signal.is_enum:
        return SIGNAL_MEMBER_FMT.format(comment=comment,
                                      range=range_,
                                      scale=scale,
                                      offset=offset,
                                      type_name=f"{database_name}_{message.snake_name}_{signal.snake_name}",
                                      name=signal.snake_name,
                                      length=length)

    #signal.is_float non funziona
    if signal.is_float_conversion:
        _type = 'float'
    else:
        _type = signal.type_name

    if signal.length <= 1:
        return SIGNAL_MEMBER_FMT_BOOL.format(comment=comment,
                                      range=range_,
                                      scale=scale,
                                      offset=offset,
                                      name=signal.snake_name,
                                      length=length)

    member = SIGNAL_MEMBER_FMT.format(comment=comment,
                                      range=range_,
                                      scale=scale,
                                      offset=offset,
                                      type_name=_type,
                                      name=signal.snake_name,
                                      length=length)

    return member

def _generate_signal(signal, bit_fields, database_name, message):
    comment = _format_comment(signal.comment)
    range_ = _format_range(signal)
    scale = _get(signal.scale, '-')
    offset = _get(signal.offset, '-')

    if signal.is_float or not bit_fields:
        length = ''
    else:
        length = f' : {signal.length}'

    if signal.is_enum:
        return SIGNAL_MEMBER_FMT.format(comment=comment,
                                      range=range_,
                                      scale=scale,
                                      offset=offset,
                                      type_name=f"{database_name}_{message.snake_name}_{signal.snake_name}",
                                      name=signal.snake_name,
                                      length=length)

    member = SIGNAL_MEMBER_FMT.format(comment=comment,
                                      range=range_,
                                      scale=scale,
                                      offset=offset,
                                      type_name=signal.type_name,
                                      name=signal.snake_name,
                                      length=length)

    return member


def _format_pack_code_mux(message,
                          mux,
                          body_lines_per_index,
                          variable_lines,
                          helper_kinds):
    signal_name, multiplexed_signals = list(mux.items())[0]
    _format_pack_code_signal(message,
                             signal_name,
                             body_lines_per_index,
                             variable_lines,
                             helper_kinds)
    multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
    signal_name = camel_to_snake_case(signal_name)

    lines = [
        '',
        f'switch (src_p->{signal_name}) {{'
    ]

    for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
        body_lines = _format_pack_code_level(message,
                                             multiplexed_signals,
                                             variable_lines,
                                             helper_kinds)
        lines.append('')
        lines.append(f'case {multiplexer_id}:')

        if body_lines:
            lines.extend(body_lines[1:-1])

        lines.append('    break;')

    lines.extend([
        '',
        'default:',
        '    break;',
        '}'])

    return [('    ' + line).rstrip() for line in lines]


def _format_pack_code_signal(message,
                             signal_name,
                             body_lines,
                             variable_lines,
                             helper_kinds):
    signal = message.get_signal_by_name(signal_name)

    if signal.is_float or signal.is_signed:
        variable = '    uint{}_t {};'.format(signal.type_length,
                                             signal.snake_name)

        if signal.is_float:
            conversion = '    memcpy(&{0}, &src_p->{0}, sizeof({0}));'.format(
                signal.snake_name)
        else:
            conversion = '    {0} = (uint{1}_t)src_p->{0};'.format(
                signal.snake_name,
                signal.type_length)

        variable_lines.append(variable)
        body_lines.append(conversion)

    for index, shift, shift_direction, mask in signal.segments(invert_shift=False):
        if signal.is_float or signal.is_signed:
            fmt = '    dst_p[{}] |= pack_{}_shift_u{}({}, {}u, 0x{:02x}u);'
        else:
            fmt = '    dst_p[{}] |= pack_{}_shift_u{}(src_p->{}, {}u, 0x{:02x}u);'

        line = fmt.format(index,
                          shift_direction,
                          signal.type_length,
                          signal.snake_name,
                          shift,
                          mask)
        body_lines.append(line)
        helper_kinds.add((shift_direction, signal.type_length))


def _format_pack_code_level(message,
                            signal_names,
                            variable_lines,
                            helper_kinds):
    """Format one pack level in a signal tree.

    """

    body_lines = []
    muxes_lines = []

    for signal_name in signal_names:
        if isinstance(signal_name, dict):
            mux_lines = _format_pack_code_mux(message,
                                              signal_name,
                                              body_lines,
                                              variable_lines,
                                              helper_kinds)
            muxes_lines += mux_lines
        else:
            _format_pack_code_signal(message,
                                     signal_name,
                                     body_lines,
                                     variable_lines,
                                     helper_kinds)

    body_lines = body_lines + muxes_lines

    if body_lines:
        body_lines = [''] + body_lines + ['']

    return body_lines


def _format_pack_code(message, helper_kinds):
    variable_lines = []
    body_lines = _format_pack_code_level(message,
                                         message.signal_tree,
                                         variable_lines,
                                         helper_kinds)

    if variable_lines:
        variable_lines = sorted(list(set(variable_lines))) + ['', '']

    return '\n'.join(variable_lines), '\n'.join(body_lines)


def _format_unpack_code_mux(database_name,
                            message,
                            mux,
                            body_lines_per_index,
                            variable_lines,
                            helper_kinds,
                            node_name):
    signal_name, multiplexed_signals = list(mux.items())[0]
    _format_unpack_code_signal(database_name,
                               message,
                               signal_name,
                               body_lines_per_index,
                               variable_lines,
                               helper_kinds)
    multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
    signal_name = camel_to_snake_case(signal_name)

    lines = [
        f'switch (dst_p->{signal_name}) {{'
    ]

    for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
        body_lines = _format_unpack_code_level(database_name,
                                               message,
                                               multiplexed_signals,
                                               variable_lines,
                                               helper_kinds,
                                               node_name)
        lines.append('')
        lines.append(f'case {multiplexer_id}:')
        lines.extend(_strip_blank_lines(body_lines))
        lines.append('    break;')

    lines.extend([
        '',
        'default:',
        '    break;',
        '}'])

    return [('    ' + line).rstrip() for line in lines]


def _format_unpack_code_signal(database_name,
                               message,
                               signal_name,
                               body_lines,
                               variable_lines,
                               helper_kinds):
    signal = message.get_signal_by_name(signal_name)
    conversion_type_name = f'uint{signal.type_length}_t'

    if signal.is_float or signal.is_signed:
        variable = f'    {conversion_type_name} {signal.snake_name};'
        variable_lines.append(variable)

    segments = signal.segments(invert_shift=True)

    for i, (index, shift, shift_direction, mask) in enumerate(segments):
        if signal.is_float or signal.is_signed:
            fmt = '    {} {} {} unpack_{}_shift_u{}(src_p[{}], {}u, 0x{:02x}u);'
        else:
            fmt = '    dst_p->{} {} {} unpack_{}_shift_u{}(src_p[{}], {}u, 0x{:02x}u);'

        cast = ''

        if signal.is_enum:
            cast = f'({database_name}_{message.snake_name}_{signal.snake_name})'

        if (not (signal.is_float or signal.is_signed)) and i != 0:
            fmt = '    dst_p->{} = {} (dst_p->{} | unpack_{}_shift_u{}(src_p[{}], {}u, 0x{:02x}u));'
            line = fmt.format(signal.snake_name,
                            cast,
                            signal.snake_name,
                            shift_direction,
                            signal.type_length,
                            index,
                            shift,
                            mask)
        else:
            line = fmt.format(signal.snake_name,
                            '=' if i == 0 else '|=',
                            cast,
                            shift_direction,
                            signal.type_length,
                            index,
                            shift,
                            mask)
        body_lines.append(line)
        helper_kinds.add((shift_direction, signal.type_length))

    if signal.is_float:
        conversion = '    memcpy(&dst_p->{0}, &{0}, sizeof(dst_p->{0}));'.format(
            signal.snake_name)
        body_lines.append(conversion)
    elif signal.is_signed:
        mask = ((1 << (signal.type_length - signal.length)) - 1)

        if mask != 0:
            mask <<= signal.length
            formatted = SIGN_EXTENSION_FMT.format(name=signal.snake_name,
                                                  shift=signal.length - 1,
                                                  mask=mask,
                                                  suffix=signal.conversion_type_suffix)
            body_lines.extend(formatted.splitlines())

        conversion = '    dst_p->{0} = (int{1}_t){0};'.format(signal.snake_name,
                                                              signal.type_length)
        body_lines.append(conversion)


def _format_unpack_code_level(database_name,
                              message,
                              signal_names,
                              variable_lines,
                              helper_kinds,
                              node_name):
    """Format one unpack level in a signal tree.

    """

    body_lines = []
    muxes_lines = []

    for signal_name in signal_names:
        if isinstance(signal_name, dict):
            mux_lines = _format_unpack_code_mux(database_name,
                                                message,
                                                signal_name,
                                                body_lines,
                                                variable_lines,
                                                helper_kinds,
                                                node_name)

            if muxes_lines:
                muxes_lines.append('')

            muxes_lines += mux_lines
        else:
            if not _is_receiver(message.get_signal_by_name(signal_name), node_name):
                continue

            _format_unpack_code_signal(database_name,
                                       message,
                                       signal_name,
                                       body_lines,
                                       variable_lines,
                                       helper_kinds)

    if body_lines:
        if body_lines[-1] != '':
            body_lines.append('')

    if muxes_lines:
        muxes_lines.append('')

    body_lines = body_lines + muxes_lines

    if body_lines:
        body_lines = [''] + body_lines

    return body_lines


def _format_unpack_code(database_name, message, helper_kinds, node_name):
    variable_lines = []
    body_lines = _format_unpack_code_level(database_name,
                                           message,
                                           message.signal_tree,
                                           variable_lines,
                                           helper_kinds,
                                           node_name)

    if variable_lines:
        variable_lines = sorted(list(set(variable_lines))) + ['', '']

    return '\n'.join(variable_lines), '\n'.join(body_lines)

def _generate_struct_converted(message, bit_fields, database_name):
    members = []

    for signal in message.signals:
        members.append(_generate_signal_converted(signal, bit_fields, database_name, message))

    if not members:
        members = [
            '    /**\n'
            '     * Dummy signal in empty message.\n'
            '     */\n'
            '    uint8_t dummy;'
        ]

    if message.comment is None:
        comment = ''
    else:
        comment = ' * {}\n *\n'.format(message.comment)

    return comment, members

def _generate_struct(message, bit_fields, database_name):
    members = []

    for signal in message.signals:
        members.append(_generate_signal(signal, bit_fields, database_name, message))

    if not members:
        members = [
            '    /**\n'
            '     * Dummy signal in empty message.\n'
            '     */\n'
            '    uint8_t dummy;'
        ]

    if message.comment is None:
        comment = ''
    else:
        comment = f' * {message.comment}\n *\n'

    return comment, members


def _format_choices(signal, signal_name):
    choices = []

    for value, name in sorted(signal.unique_choices.items()):
        if signal.is_signed:
            fmt = '{signal_name}_{name}_CHOICE ({value})'
        else:
            fmt = '{signal_name}_{name}_CHOICE ({value}u)'

        choices.append(fmt.format(signal_name=signal_name.upper(),
                                name=str(name),
                                value=value))

    return choices


def _generate_encode_decode(message, use_float):
    encode_decode = []

    floating_point_type = _get_floating_point_type(use_float)
    for signal in message.signals:
        scale = signal.decimal.scale
        offset = signal.decimal.offset
        formatted_scale = _format_decimal(scale, is_float=True, use_float=use_float)
        formatted_offset = _format_decimal(offset, is_float=True, use_float=use_float)

        if offset == 0 and scale == 1:
            encoding = 'value'
            decoding = f'({floating_point_type})value'
        elif scale == 1 and offset != 0 and offset % 1 == 0:
            encoding = f'value - {offset}'
            decoding = f'value + {offset}'
        elif offset != 0 and scale != 1:
            encoding = f'(value - {formatted_offset}) / {formatted_scale}'
            decoding = f'(({floating_point_type})value * {formatted_scale}) + {formatted_offset}'
        elif offset != 0:
            encoding = f'value - {formatted_offset}'
            decoding = f'({floating_point_type})value + {formatted_offset}'
        else:
            encoding = f'value / {formatted_scale}'
            decoding = f'({floating_point_type})value * {formatted_scale}'

        if signal.maximum_value != None:
            encoding = f'canlib_min({signal.maximum_value}, {encoding})'
        if signal.minimum_value != None:
            encoding = f'canlib_max({signal.minimum_value}, {encoding})'

        encode_decode.append((encoding, decoding))

    return encode_decode


def _generate_is_in_range(message):
    """Generate range checks for all signals in given message.

    """

    checks = []

    for signal in message.signals:
        scale = signal.decimal.scale
        offset = (signal.decimal.offset / scale)
        minimum = signal.decimal.minimum
        maximum = signal.decimal.maximum

        if minimum is not None:
            minimum = (minimum / scale - offset)

        if maximum is not None:
            maximum = (maximum / scale - offset)

        if minimum is None and signal.minimum_value is not None:
            if signal.minimum_value > signal.minimum_type_value:
                minimum = signal.minimum_value

        if maximum is None and signal.maximum_value is not None:
            if signal.maximum_value < signal.maximum_type_value:
                maximum = signal.maximum_value

        suffix = signal.type_suffix
        check = []

        if minimum is not None:
            if not signal.is_float:
                minimum = Decimal(int(minimum))

            minimum_type_value = signal.minimum_type_value

            if (minimum_type_value is None) or (minimum > minimum_type_value):
                minimum = _format_decimal(minimum, signal.is_float)
                check.append(f'(value >= {minimum}{suffix})')

        if maximum is not None:
            if not signal.is_float:
                maximum = Decimal(int(maximum))

            maximum_type_value = signal.maximum_type_value

            if (maximum_type_value is None) or (maximum < maximum_type_value):
                maximum = _format_decimal(maximum, signal.is_float)
                check.append(f'(value <= {maximum}{suffix})')

        if not check:
            check = ['true']
        elif len(check) == 1:
            check = [check[0][1:-1]]

        check = ' && '.join(check)

        checks.append(check)

    return checks


def _generate_frame_id_defines(database_name, messages, node_name):
    return '\n'.join([
        '#define {}_{}_FRAME_ID (0x{:02x}u)'.format(
            database_name.upper(),
            message.snake_name.upper(),
            message.frame_id)
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])


def _generate_frame_length_defines(database_name, messages: List[Message], node_name):
    result = '\n'.join([
        '#define {}_{}_BYTE_SIZE ({}u)'.format(
            database_name.upper(),
            message.snake_name.upper(),
            message.length)
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])
    return result


def _generate_frame_cycle_time_defines(database_name, messages, node_name):
    result = '\n'.join([
        '#define {}_{}_CYCLE_TIME_MS ({}u)'.format(
            database_name.upper(),
            message.snake_name.upper(),
            message.cycle_time)
        for message in messages if message.cycle_time is not None and
                                _is_sender_or_receiver(message, node_name)
    ] + [
        '#define {}_{}_CYCLE_TIME_MS ({}_ONESHOT)'.format(
            database_name.upper(),
            message.snake_name.upper(),
            database_name.upper())
        for message in messages if message.cycle_time is None and
                                _is_sender_or_receiver(message, node_name)
    ])

    return result


def _generate_is_extended_frame_defines(database_name, messages, node_name):
    result = '\n'.join([
        '#define {}_{}_IS_EXTENDED ({})'.format(
            database_name.upper(),
            message.snake_name.upper(),
            int(message.is_extended_frame))
        for message in messages if _is_sender_or_receiver(message, node_name)
    ])
    return result


def _generate_choices_defines(database_name, messages, node_name):
    choices_defines = []

    for message in messages:
        is_sender = _is_sender(message, node_name)
        for signal in message.signals:
            if signal.choices is None:
                continue
            if not is_sender and not _is_receiver(signal, node_name):
                continue
            choices = _format_choices(signal, signal.snake_name)
            signal_choices_defines = '\n'.join([
                '#define {}_{}_{}'.format(database_name.upper(),
                                          message.snake_name.upper(),
                                          choice)
                for choice in choices
            ])
            choices_defines.append(signal_choices_defines)

    return '\n\n'.join(choices_defines)

def _generate_masks(database_name, messages):
    topics = {}
    for msg in messages:
        if msg.topic_name in topics:
            topics[msg.topic_name][1].append(msg)
        else:
            topics[msg.topic_name] = (msg.topic_id, [msg])
    ret = ''

    for topic_name in topics:
        if topic_name == None:
            continue
        topic_id = topics[topic_name][0]
        msgs = topics[topic_name][1]
        ret += f'/* TOPIC {topic_name.upper()} */\n'
        ret += f'#define {database_name.upper()}_TOPIC_MASK_{topic_name.upper()} 0b00000011111\n\n'
        if topic_id is not None:
            ret += f'#define {database_name.upper()}_TOPIC_FILTER_{topic_name.upper()} {"0x{:X}".format(topic_id)} // dec: {topic_id} bin: {"0b{0:>011b}".format(topic_id)}\n\n'
        for msg in msgs:
            ret += f'#define {database_name.upper()}_ID_{msg.snake_name.upper()} {"0x{:X}".format(msg.frame_id)} // dec: {msg.frame_id} bin: {"0b{0:>011b}".format(msg.frame_id)}\n'
        ret += '\n'
    return ret

def _generate_structs(database_name, messages, bit_fields, node_name):
    structs = []

    for message in messages:
        for signal in message.signals:
            if signal.is_enum:
                enum = SIGNAL_ENUM_START_DECLARATION
                for choice in signal._signal.choices:
                    enum += f"\t{database_name}_{message.snake_name}_{signal.snake_name}_{signal._signal.choices[choice]} = {choice},\n"
                enum += SIGNAL_ENUM_END_DECLARATION.format(type_name = f"{database_name}_{message.snake_name}_{signal.snake_name}")
                structs.append(enum)

    for message in messages:
        if _is_sender_or_receiver(message, node_name):
            comment, members = _generate_struct(message, bit_fields, database_name)
            structs.append(
                STRUCT_FMT.format(comment=comment,
                                database_message_name=message.name,
                                message_name=message.snake_name,
                                database_name=database_name,
                                members='\n\n'.join(members)))
            comment, members = _generate_struct_converted(message, bit_fields, database_name)
            structs.append(
                STRUCT_FMT.format(comment=comment,
                                database_message_name=message.name,
                                message_name=message.snake_name + "_converted",
                                database_name=database_name,
                                members='\n\n'.join(members)))

    return '\n'.join(structs)

def _is_sender(message, node_name):
    return node_name is None or node_name in message.senders

def _is_receiver(signal, node_name):
    return node_name is None or node_name in signal.receivers

def _is_sender_or_receiver(message, node_name):
    if _is_sender(message, node_name):
        return True
    return any(_is_receiver(signal, node_name) for signal in message.signals)

def _get_floating_point_type(use_float):
    return 'float' if use_float else 'double'

def _get_conversion_to_raw_head(database_name, message):
    signals = []
    for signal in message.signals:
        if signal.is_enum:
            type = signal.enum_name
        elif signal.is_float_conversion:
            type = "float"
        else:
            type = signal.type_name
        signals.append(SIGNAL_DECLARATION_TO_.format(signal_type=type,
                                                    signal_name=signal.snake_name))
    if len(signals) <= 0:
        return '\n'
    signals[-1] = signals[-1][:-2]
    message_conversion_to_raw = MESSAGE_DEFINITION_CONVERSION_TO_RAW.format(database_name=database_name,
                                                                            message_name=message.snake_name,
                                                                            struct_type=f"{database_name}_{message.snake_name}_t",
                                                                            signals = ''.join(signals))
    return message_conversion_to_raw[:-2] + "\n)"

def _get_raw_to_conversion_head(database_name, message):
    signals = []
    for signal in message.signals:
        if signal.is_enum:
            type = signal.enum_name
        elif signal.is_float_conversion:
            type = "float"
        else:
            type = signal.type_name
        signals.append(SIGNAL_DECLARATION_TO_.format(signal_type=type,
                                                    signal_name=signal.snake_name))
    if len(signals) <= 0:
        return '\n'
    signals[-1] = signals[-1][:-2]
    message_raw_to_conversion = MESSAGE_DEFINITION_RAW_TO_CONVERSION.format(database_name=database_name,
                                                                            message_name=message.snake_name,
                                                                            struct_type=f"{database_name}_{message.snake_name}_converted_t",
                                                                            signals = "".join(signals))
    return message_raw_to_conversion[:-2] + "\n)"

def _generate_unions(database_name, messages):
    raw = ''
    converted = ''
    for msg in messages:
        raw += MESSAGE_UNION.format(type_name=msg.struct_name_raw, name=msg.snake_name)
        converted += MESSAGE_UNION.format(type_name=msg.struct_name_converted, name=msg.snake_name)
    raw = UNION.format(messages=raw, name=f'_{database_name}_all_struct_raw')
    converted = UNION.format(messages=converted, name=f'_{database_name}_all_struct_converted')

    return raw + "\n" + converted

def _generate_declarations(database_name, messages: List[Message], floating_point_numbers, use_float, node_name):
    declarations = []

    for message in messages:
        signal_declarations = []
        is_sender = _is_sender(message, node_name)
        is_receiver = node_name is None

        enum_to_string = ""
        for signal in message.signals:
            if _is_receiver(signal, node_name):
                is_receiver = True

            signal_declaration = ''
            
            if floating_point_numbers and signal.is_float_conversion:
                if is_sender:
                    signal_declaration += SIGNAL_DECLARATION_ENCODE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        conversion_type=_get_floating_point_type(use_float))
                if node_name is None or _is_receiver(signal, node_name):
                    signal_declaration += SIGNAL_DECLARATION_DECODE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        conversion_type=_get_floating_point_type(use_float))
            if signal.is_integer_conversion:
                if is_sender:
                    signal_declaration += SIGNAL_DECLARATION_ENCODE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        conversion_type=signal.type_name)
                if node_name is None or _is_receiver(signal, node_name):
                    signal_declaration += SIGNAL_DECLARATION_DECODE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        conversion_type=signal.type_name)
            if is_sender or _is_receiver(signal, node_name):
                signal_declaration += SIGNAL_DECLARATION_IS_IN_RANGE_FMT.format(
                    database_name=database_name,
                    message_name=message.snake_name,
                    signal_name=signal.snake_name,
                    type_name=signal.type_name)
                
                signal_declarations.append(signal_declaration)

            if signal.is_enum:
                enum_to_string += ENUM_TO_STRING_DECLARATION.format(
                    database_name = database_name,
                    message_name = message.snake_name,
                    signal_name = signal.snake_name
                )
            # if signal.length <= 1:
            #     signal_declarations.append(BITSET_BIT_OP_DECLARATION.format(
            #         database_name = database_name,
            #         message_name = message.snake_name,
            #         signal_name = signal.snake_name,
            #         enum_type = signal.enum_name
            #     ))
        declaration = ""

        declarations.append(_get_raw_to_conversion_head(database_name, message) + ";\n")
        declarations.append(_get_conversion_to_raw_head(database_name, message) + ";\n")

        declarations.append(MESSAGE_DECLARATION_RAW_TO_CONVERSION_STRUCT.format(database_name=database_name,
                                                                    message_name=message.snake_name,
                                                                    struct_type_out=f"{database_name}_{message.snake_name}_converted_t",
                                                                    struct_type_in=f"const {database_name}_{message.snake_name}_t"))

        declarations.append(MESSAGE_DECLARATION_CONVERSION_TO_RAW_STRUCT.format(database_name=database_name,
                                                                    message_name=message.snake_name,
                                                                    struct_type_in=f"{database_name}_{message.snake_name}_t",
                                                                    struct_type_out=f"const {database_name}_{message.snake_name}_converted_t"))

        msg_name = message.snake_name
        if message.has_conversions:
            msg_name += "_converted"

        declarations.append(enum_to_string)

        declarations.append(MESSAGE_DECLARATION_TO_STRING.format(database_name=database_name,
                                                                message_name=msg_name))
        declarations.append(MESSAGE_DECLARATION_TO_STRING_FILE.format(database_name=database_name,
                                                                message_name=msg_name))

        declarations.append(MESSAGE_DECLARATION_FIELDS.format(database_name=database_name,
                                                        message_name=message.snake_name))
        declarations.append(MESSAGE_DECLARATION_FIELDS_FILE.format(database_name=database_name,
                                                        message_name=message.snake_name))

        if is_sender:
            declaration += DECLARATION_PACK_FMT.format(database_name=database_name,
                                                       database_message_name=message.name,
                                                       message_name=message.snake_name)
        if is_receiver:
            declaration += DECLARATION_UNPACK_FMT.format(database_name=database_name,
                                                         database_message_name=message.name,
                                                         message_name=message.snake_name)

        if signal_declarations:
            declaration += '\n' + '\n'.join(signal_declarations)

        if declaration:
            declarations.append(declaration)

    declarations.append(NET_ID_IS_MESSAGE_DECLARATION.format(database_name=database_name))
    declarations.append(f'int {database_name}_to_string_from_id(uint16_t message_id, void* message, char* buffer);')
    declarations.append(f'int {database_name}_fields_from_id(uint16_t message_id, char* buffer);')
    declarations.append(f'int {database_name}_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);')
    declarations.append(f'int {database_name}_fields_file_from_id(uint16_t message_id, FILE* buffer);')


    return '\n'.join(declarations)


def _generate_definitions(database_name, messages: List[Message], floating_point_numbers, use_float, node_name):
    definitions = []
    pack_helper_kinds = set()
    unpack_helper_kinds = set()
    devices_new = ''
    devices_free = ''
    devices_deserialize = ''
    devices_serialize = ''

    msg_name_from_id = ''
    index_from_id = ''
    id_from_index = ''
    id_is_message = ''

    to_string_from_id = '''int {database_name}_to_string_from_id(uint16_t message_id,
                                void* message,
                                char* buffer
) {{
    switch (message_id) {{
    '''.format(database_name=database_name)

    fields_from_id = '''int {database_name}_fields_from_id(uint16_t message_id, char* buffer) {{
    switch (message_id) {{
    '''.format(database_name=database_name)

    to_string_file_from_id = '''int {database_name}_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer) {{
    switch (message_id) {{
    '''.format(database_name=database_name)

    fields_file_from_id = '''int {database_name}_fields_file_from_id(uint16_t message_id, FILE* buffer) {{
    switch (message_id) {{
    '''.format(database_name=database_name)

    for message in messages:
        signal_definitions = []
        is_sender = _is_sender(message, node_name)
        is_receiver = node_name is None

        msg_name_from_id += MSG_NAME_FROM_ID_CONTENT.format(message._message._frame_id,
                                                            message.snake_name)

        index_from_id += '\t\tcase {}: return {};\n'.format(message._message._frame_id,
                                                    f'{database_name.upper()}_{message.snake_name.upper()}_INDEX')
        id_from_index += '\t\tcase {}: return {};\n'.format(f'{database_name.upper()}_{message.snake_name.upper()}_INDEX',
                                                    message._message._frame_id)

        conversion_comp = ""
        if message.has_conversions:
            conversion_comp = DEVICE_MESSAGE_DESERIALIZE_CONVERSION_COMPONENT.format(message_name=message.snake_name,
                                                                    database_name=database_name)
        devices_deserialize += DEVICE_MESSAGE_DESERIALIZE.format(id=message._message._frame_id,
                                                                message_name=message.snake_name,
                                                                database_name=database_name,
                                                                message_length=message.length,
                                                                conversion_component=conversion_comp)
        if message.has_conversions:
            devices_serialize += DEVICE_MESSAGE_SERIALIZE_CONVERSION.format(id=message._message._frame_id,
                                                                message_name=message.snake_name,
                                                                database_name=database_name,
                                                                message_length=message.length)
        else:
            devices_serialize += DEVICE_MESSAGE_SERIALIZE_RAW.format(id=message._message._frame_id,
                                                            message_name=message.snake_name,
                                                            database_name=database_name,
                                                            message_length=message.length)
        
        msg_name = message.snake_name
        if message.has_conversions:
            msg_name += "_converted"
        
        to_string_from_id += MESSAGE_STRING_FROM_ID.format(id=message._message._frame_id,
                                                            database_name=database_name,
                                                            message_name=msg_name)
        fields_from_id += MESSAGE_FIELD_FROM_ID.format(id=message._message._frame_id,
                                                            database_name=database_name,
                                                            message_name=message.snake_name)
        to_string_file_from_id += MESSAGE_FILE_FROM_ID.format(id=message._message._frame_id,
                                                            database_name=database_name,
                                                            message_name=msg_name)
        fields_file_from_id += MESSAGE_FIELD_FILE_FROM_ID.format(id=message._message._frame_id,
                                                            database_name=database_name,
                                                            message_name=message.snake_name)
                                                            
        message_to_string = MESSAGE_DEFINITION_TO_STRING.format(database_name=database_name,
                                                                message_name=msg_name)
        message_to_string_file = MESSAGE_DEFINITION_TO_STRING_FILE.format(database_name=database_name,
                                                                message_name=msg_name)
        signals_specifiers = ""
        signals_to_string = '''
#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
'''
        message_fields_string = MESSAGE_DEFINITION_FIELDS.format(database_name=database_name,
                                                        message_name=message.snake_name)
        message_fields_file = MESSAGE_DEFINITION_FIELDS_FILE.format(database_name=database_name,
                                                        message_name=message.snake_name)
        message_fields = ""

        message_raw_to_conversion = _get_raw_to_conversion_head(database_name, message) + '''{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
'''
        message_conversion_to_raw = _get_conversion_to_raw_head(database_name, message) +  '''{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
'''

        id_is_message += NET_ID_IS_MESSAGE_BODY.format(db_name=database_name.upper(), msg_name=message.snake_name.upper())

        message_raw_to_conversion_struct = MESSAGE_DEFINITION_RAW_TO_CONVERSION_STRUCT.format(database_name=database_name,
                                                                                message_name=message.snake_name,
                                                                                struct_type_out=f"{database_name}_{message.snake_name}_converted_t",
                                                                                struct_type_in=f"const {database_name}_{message.snake_name}_t")

        message_conversion_to_raw_struct = MESSAGE_DEFINITION_CONVERSION_TO_RAW_STRUCT.format(database_name=database_name,
                                                                    message_name=message.snake_name,
                                                                    struct_type_in=f"{database_name}_{message.snake_name}_t",
                                                                    struct_type_out=f"const {database_name}_{message.snake_name}_converted_t")
        enum_to_string = ''
        for signal, (encode, decode), check in zip(message.signals,
                                                   _generate_encode_decode(message, use_float),
                                                   _generate_is_in_range(message)):
            if _is_receiver(signal, node_name):
                is_receiver = True
            
            if signal.is_enum:
                body = ''
                for choice in signal.unique_choices:
                    body += CHOICE_TO_STRING.format(case=choice, choice=signal.unique_choices[choice])
                enum_to_string += ENUM_TO_STRING.format(database_name=database_name, message_name=message.snake_name, signal_name=signal.snake_name, body=body)
            
            if check == 'true':
                unused = '    (void)value;\n\n'
            else:
                unused = ''

            signal_definition = ''
            signals_to_string += SIGNAL_DEFINITION_TO_STRING.format(signal_name = signal.snake_name)
            message_fields += SIGNAL_DEFINITION_FIELDS.format(signal_name = signal.snake_name)

            if floating_point_numbers and signal.is_float_conversion:
                signals_specifiers += SIGNAL_DEFINITION_SPECIFIER.format(specifier = type_to_specifier["float"])
                message_raw_to_conversion += SIGNAL_DEFINITION_RAW_TO_CONVERT_DECODE.format(signal_name=signal.snake_name,
                                                                    database_name=database_name,
                                                                    message_name=message.snake_name)
                message_conversion_to_raw += SIGNAL_DEFINITION_CONVERT_TO_RAW_ENCODE.format(signal_name=signal.snake_name,
                                                                    database_name=database_name,
                                                                    message_name=message.snake_name)
                                 
                message_raw_to_conversion_struct += SIGNAL_DEFINITION_RAW_TO_CONVERT_STRUCT_DECODE.format(signal_name=signal.snake_name,
                                                                    database_name=database_name,
                                                                    message_name=message.snake_name)

                message_conversion_to_raw_struct += SIGNAL_DEFINITION_CONVERT_TO_RAW_STRUCT_ENCODE.format(signal_name=signal.snake_name,
                                                                    database_name=database_name,
                                                                    message_name=message.snake_name)
                if is_sender:

                    signal_definition += SIGNAL_DEFINITION_ENCODE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        encode=encode,
                        conversion_type=_get_floating_point_type(use_float))
                if node_name is None or _is_receiver(signal, node_name):
                    signal_definition += SIGNAL_DEFINITION_DECODE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        decode=decode,
                        conversion_type=_get_floating_point_type(use_float))

            if signal.is_integer_conversion:
                signals_specifiers += SIGNAL_DEFINITION_SPECIFIER.format(specifier = type_to_specifier[signal.type_name])
                message_raw_to_conversion += SIGNAL_DEFINITION_RAW_TO_CONVERT_DECODE.format(signal_name=signal.snake_name,
                                                                    database_name=database_name,
                                                                    message_name=message.snake_name)
                message_conversion_to_raw += SIGNAL_DEFINITION_CONVERT_TO_RAW_ENCODE.format(signal_name=signal.snake_name,
                                                                    database_name=database_name,
                                                                    message_name=message.snake_name)
                                 
                message_raw_to_conversion_struct += SIGNAL_DEFINITION_RAW_TO_CONVERT_STRUCT_DECODE.format(signal_name=signal.snake_name,
                                                                    database_name=database_name,
                                                                    message_name=message.snake_name)

                message_conversion_to_raw_struct += SIGNAL_DEFINITION_CONVERT_TO_RAW_STRUCT_ENCODE.format(signal_name=signal.snake_name,
                                                                    database_name=database_name,
                                                                    message_name=message.snake_name)
                if is_sender:

                    signal_definition += SIGNAL_DEFINITION_ENCODE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        encode=encode,
                        conversion_type=signal.type_name)
                if node_name is None or _is_receiver(signal, node_name):
                    signal_definition += SIGNAL_DEFINITION_DECODE_FMT.format(
                        database_name=database_name,
                        message_name=message.snake_name,
                        signal_name=signal.snake_name,
                        type_name=signal.type_name,
                        decode=decode,
                        conversion_type=signal.type_name)

            if not (signal.is_float_conversion or signal.is_integer_conversion):
                signals_specifiers += SIGNAL_DEFINITION_SPECIFIER.format(specifier = type_to_specifier[signal.type_name])
                message_raw_to_conversion_struct += SIGNAL_DEFINITION_RAW_TO_CONVERT_STRUCT.format(signal_name=signal.snake_name)
                message_conversion_to_raw_struct += SIGNAL_DEFINITION_CONVERT_TO_RAW_STRUCT.format(signal_name=signal.snake_name)
                message_raw_to_conversion += SIGNAL_DEFINITION_RAW_TO_CONVERT.format(signal_name=signal.snake_name)
                message_conversion_to_raw += SIGNAL_DEFINITION_CONVERT_TO_RAW.format(signal_name=signal.snake_name)

            if is_sender or _is_receiver(signal, node_name):
                signal_definition += SIGNAL_DEFINITION_IS_IN_RANGE_FMT.format(
                    database_name=database_name,
                    message_name=message.snake_name,
                    signal_name=signal.snake_name,
                    type_name=signal.type_name,
                    unused=unused,
                    check=check)

                signal_definitions.append(signal_definition)
        
        if message._message.length > 0:
            signal_definitions.append(message_raw_to_conversion + "}\n")
            signal_definitions.append(message_conversion_to_raw + "}\n")
            signal_definitions.append(message_raw_to_conversion_struct+"}\n")
            signal_definitions.append(message_conversion_to_raw_struct+"}\n")
            signal_definitions.append(message_to_string + signals_specifiers[:-4] + ",\n" + signals_to_string[:-2] + "\n);\n}\n")
            signal_definitions.append(message_to_string_file + signals_specifiers[:-4] + ",\n" + signals_to_string[:-2] + "\n);\n}\n")
            signal_definitions.append(message_fields_string + message_fields[:-4] + ");\n}\n")
            signal_definitions.append(message_fields_file + message_fields[:-4] + ");\n}\n")
        else:
            signal_definitions.append(DEFINITION_TO_STRING_FILE_NO_SIGNALS.format(database_name=database_name,
                                                                message_name=msg_name))
        if message.length > 0:
            pack_variables, pack_body = _format_pack_code(message,
                                                          pack_helper_kinds)
            unpack_variables, unpack_body = _format_unpack_code(database_name,
                                                                message,
                                                                unpack_helper_kinds,
                                                                node_name)
            pack_unused = ''
            unpack_unused = ''

            if not pack_body:
                pack_unused += '    (void)src_p;\n\n'

            if not unpack_body:
                unpack_unused += '    (void)dst_p;\n'
                unpack_unused += '    (void)src_p;\n\n'

            definition = ""
            if is_sender:
                definition += DEFINITION_PACK_FMT.format(database_name=database_name,
                                                         database_message_name=message.name,
                                                         message_name=message.snake_name,
                                                         message_length=message.length,
                                                         pack_unused=pack_unused,
                                                         pack_variables=pack_variables,
                                                         pack_body=pack_body)
            if is_receiver:
                definition += DEFINITION_UNPACK_FMT.format(database_name=database_name,
                                                           database_message_name=message.name,
                                                           message_name=message.snake_name,
                                                           message_length=message.length,
                                                           unpack_unused=unpack_unused,
                                                           unpack_variables=unpack_variables,
                                                           unpack_body=unpack_body)
        else:
            definition = EMPTY_DEFINITION_FMT.format(database_name=database_name,
                                                     message_name=message.snake_name)

        if signal_definitions:
            definition += '\n' + '\n'.join(signal_definitions)

        if definition:
            definitions.append(definition)

        definitions.append(enum_to_string)
    
    definitions.append(NET_ID_IS_MESSAGE_DEFINITION.format(
        database_name=database_name,
        net_id_is_message_body=id_is_message))
    definitions.append(MSG_NAME_FROM_ID.format(database_name=database_name, body=msg_name_from_id))
    definitions.append(INDEX_FROM_ID.format(database_name=database_name, body=index_from_id))
    definitions.append(ID_FROM_INDEX.format(database_name=database_name, body=id_from_index))
    definitions.append(to_string_from_id + "}\n\treturn -1;\n}\n")
    definitions.append(fields_from_id + "}\n\treturn -1;\n}\n")
    definitions.append(to_string_file_from_id + "}\n\treturn -1;\n}\n")
    definitions.append(fields_file_from_id + "}\n\treturn -1;\n}\n")

    definitions.append(DEVICES_DEFINITIONS.format(database_name=database_name,
                                                devices_new_body=devices_new,
                                                devices_free_body=devices_free,
                                                devices_deserialize_body=devices_deserialize,
                                                devices_serialize_body=devices_serialize))

    return '\n'.join(definitions), (pack_helper_kinds, unpack_helper_kinds)


def _generate_helpers_kind(kinds, left_format, right_format):
    formats = {
        'left': left_format,
        'right': right_format
    }
    helpers = []

    for shift_direction, length in sorted(kinds):
        var_type = f'uint{length}_t'
        helper = formats[shift_direction].format(length=length,
                                                 var_type=var_type)
        helpers.append(helper)

    return helpers


def _generate_helpers(kinds):
    pack_helpers = _generate_helpers_kind(kinds[0],
                                          PACK_HELPER_LEFT_SHIFT_FMT,
                                          PACK_HELPER_RIGHT_SHIFT_FMT)
    unpack_helpers = _generate_helpers_kind(kinds[1],
                                            UNPACK_HELPER_LEFT_SHIFT_FMT,
                                            UNPACK_HELPER_RIGHT_SHIFT_FMT)
    helpers = pack_helpers + unpack_helpers

    if helpers:
        helpers.append('')

    return '\n'.join(helpers)


def _generate_fuzzer_source(database_name,
                            messages,
                            date,
                            header_name,
                            source_name,
                            fuzzer_source_name):
    tests = []
    calls = []

    for message in messages:
        name = '{}_{}'.format(database_name,
                              camel_to_snake_case(message.name))

        test = TEST_FMT.format(name=name)
        tests.append(test)

        call = f'    test_{name}(data_p, size);'
        calls.append(call)

    source = FUZZER_SOURCE_FMT.format(version=__version__,
                                      date=date,
                                      header=header_name,
                                      tests='\n'.join(tests),
                                      llvm_body='\n'.join(calls))

    makefile = FUZZER_MAKEFILE_FMT.format(version=__version__,
                                          date=date,
                                          source=source_name,
                                          fuzzer_source=fuzzer_source_name)

    return source, makefile

def _generate_indexes(database_name, messages):
    ret = ''
    for i, message in enumerate(messages):
        ret += MESSAGE_INDEX.format(database_name=database_name.upper(),
                                    message_name=message.snake_name.upper(),
                                    index=i)
    return ret

def generate(database,
             database_name,
             header_name,
             source_name,
             fuzzer_source_name,
             floating_point_numbers=True,
             bit_fields=False,
             use_float=False,
             node_name=None):
    """Generate C source code from given CAN database `database`.

    `database_name` is used as a prefix for all defines, data
    structures and functions.

    `header_name` is the file name of the C header file, which is
    included by the C source file.

    `source_name` is the file name of the C source file, which is
    needed by the fuzzer makefile.

    `fuzzer_source_name` is the file name of the C source file, which
    is needed by the fuzzer makefile.

    Set `floating_point_numbers` to ``True`` to allow floating point
    numbers in the generated code.

    Set `bit_fields` to ``True`` to generate bit fields in structs.
    
    Set `use_float` to ``True`` to prefer the `float` type instead
    of the `double` type for floating point numbers.

    `node_name` specifies the node for which message packers will be generated.
    For all other messages, unpackers will be generated. If `node_name` is not
    provided, both packers and unpackers will be generated. 

    This function returns a tuple of the C header and source files as
    strings.

    """

    date = time.ctime()
    messages = [Message(message, database_name) for message in database.messages]
    #messages[0]._message._frame_id
    include_guard = f'{database_name.upper()}_H'
    general_defines = f'#define {database_name.upper()}_ONESHOT (-1)'
    frame_id_defines = _generate_frame_id_defines(database_name, messages, node_name)
    frame_length_defines = _generate_frame_length_defines(database_name,
                                                          messages,
                                                          node_name)
    is_extended_frame_defines = _generate_is_extended_frame_defines(
        database_name,
        messages,
        node_name)
    frame_cycle_time_defines = _generate_frame_cycle_time_defines(
        database_name,
        messages,
        node_name)
    choices_defines = _generate_choices_defines(database_name, messages, node_name)
    structs = _generate_structs(database_name, messages, bit_fields, node_name)
    masks = _generate_masks(database_name, messages)    #only for json
    declarations = _generate_declarations(database_name,
                                          messages,
                                          floating_point_numbers,
                                          use_float,
                                          node_name)
    definitions, helper_kinds = _generate_definitions(database_name,
                                                      messages,
                                                      floating_point_numbers,
                                                      use_float,
                                                      node_name)
    helpers = _generate_helpers(helper_kinds)
    message_indexes = _generate_indexes(database_name, messages)
    unions = _generate_unions(database_name, messages)

    header = HEADER_FMT.format(version=__version__,
                               date=date,
                               general_defines=general_defines,
                               include_guard=include_guard,
                               frame_id_defines=frame_id_defines,
                               frame_length_defines=frame_length_defines,
                               is_extended_frame_defines=is_extended_frame_defines,
                               frame_cycle_time_defines=frame_cycle_time_defines,
                               masks_define=masks,
                               choices_defines=choices_defines,
                               message_indexes=message_indexes,
                               database_name=database_name,
                               msg_count=len(messages),
                               structs=structs,
                               declarations=declarations,
                               unions=unions,
                               timestamp=int(time.time()))

    source = SOURCE_FMT.format(version=__version__,
                               date=date,
                               header=header_name,
                               helpers=helpers,
                               definitions=definitions)

    fuzzer_source, fuzzer_makefile = _generate_fuzzer_source(
        database_name,
        messages,
        date,
        header_name,
        source_name,
        fuzzer_source_name)

    return header, source, fuzzer_source, fuzzer_makefile


def generate_devices_sources():
    return DEVICES_HEADER, DEVICES_SOURCE
